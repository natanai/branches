<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Prevent mobile browsers from zooming on form controls by disabling user scaling -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Branching Dialogue Editor</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f7f7f7;
    }
    #app {
      max-width: 600px;
      margin: 0 auto;
      padding: 16px;
    }
    h2 {
      text-align: center;
      margin-bottom: 16px;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }
    #controls button {
      flex: 1 1 auto;
      padding: 6px;
    }
    #controls input[type="file"] {
      flex: 1 1 auto;
    }
    #editor {
      background: #fff;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    textarea {
      width: 100%;
      min-height: 60px;
      padding: 6px;
      box-sizing: border-box;
      margin-bottom: 12px;
      resize: vertical;
      font-size: 1rem;
    }
    .response {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 8px;
    }
    .response input[type="text"] {
      flex: 1 1 auto;
      padding: 4px;
    }
    .response button {
      flex: 0 0 auto;
      padding: 4px 6px;
      font-size: 0.85rem;
    }
    .link-info {
      flex: 0 0 auto;
      font-size: 0.8rem;
      padding: 4px 6px;
    }
    #addResponseButton {
      display: block;
      width: 100%;
      margin-top: 8px;
      padding: 8px;
    }
    #nodeSelect {
      width: 100%;
      padding: 6px;
      margin-bottom: 12px;
      box-sizing: border-box;
    }

    /* Ensure form controls have at least a 16px font size to prevent mobile auto-zoom */
    input[type="text"], textarea, button, select {
      font-size: 16px !important;
    }
  </style>
</head>
<body>
<div id="app">
  <h2>Branching Dialogue Editor</h2>
  <div id="controls">
    <button id="newNodeButton">New Node</button>
    <!-- Only TXT export and import; JSON functionality removed -->
    <button id="exportTextButton">Save TXT</button>
    <button id="backButton">Back</button>
    <button id="refreshNamesButton">Refresh Names</button>
    <input type="file" id="importFile" accept=".txt">
  </div>
  <div>
    <label for="nodeSelect">Go to Node:</label>
    <select id="nodeSelect"></select>
  </div>

  <!-- History display (hidden now to avoid clutter) -->
  <div id="historySection" style="margin-top: 12px; display:none;">
    <h4 style="margin-bottom:4px;">History</h4>
    <div id="historyList" style="font-size:0.9rem; line-height:1.4;"></div>
  </div>
  <div id="editor">
    <h3>Node <span id="nodeIdDisplay"></span></h3>
    <label for="npcInput">NPC says:</label>
    <textarea id="npcInput" placeholder="Enter NPC dialogue..."></textarea>
    <h4>Player Responses:</h4>
    <div id="responsesContainer"></div>
    <button id="addResponseButton">Add Response</button>
  </div>

  <!-- NPC name and conversation log -->
  <div style="margin-top: 12px;">
    <label for="npcNameInput">NPC Name:</label>
    <input type="text" id="npcNameInput" placeholder="NPC" style="width:100%; padding:6px; box-sizing:border-box;" />
  </div>
  <div id="conversationSection" style="margin-top: 12px;">
    <h4 style="margin-bottom:4px;">Conversation</h4>
    <div id="conversationLog" style="font-size:0.9rem; line-height:1.4;"></div>
  </div>
</div>

<script>
// Self-invoking function to avoid polluting the global scope
(function() {
  let nodes = {};
  let currentNodeId = null;
  let nextNodeIdCounter = 1;
  // Keeps track of the path taken through the conversation. Each entry is a node id.
  let history = [];
  // Name of the NPC character
  let npcName = '';
  // Holds the conversation log entries: {speaker: string, text: string}
  // Each entry is either {type:'npc', nodeId: number} or {type:'player', text: string}
  let conversationLog = [];

  // Helper to create a short preview of a node's NPC text.
  // Cleans whitespace and truncates long strings with an ellipsis.
  function getPreview(text) {
    const cleaned = (text || '').trim().replace(/\s+/g, ' ');
    if (!cleaned) return '[no text]';
    return cleaned.length > 30 ? cleaned.slice(0, 30) + '…' : cleaned;
  }

  // Utility: create a new dialogue node
  function createNode(text = '') {
    const id = nextNodeIdCounter++;
    nodes[id] = { id: id, text: text, responses: [] };
    updateNodeSelect();
    return id;
  }

  // Render the currently selected node
  function renderNode(id) {
    currentNodeId = id;
    const node = nodes[id];
    if (!node) return;
    const header = document.getElementById('nodeIdDisplay');
    // Display both id and a preview of the NPC text for easier identification
    const preview = getPreview(node.text);
    header.textContent = `${id}: ${preview}`;
    document.getElementById('npcInput').value = node.text;
    const container = document.getElementById('responsesContainer');
    container.innerHTML = '';
    node.responses.forEach((resp, index) => {
      const div = document.createElement('div');
      div.className = 'response';
      const input = document.createElement('input');
      input.type = 'text';
      input.value = resp.text;
      input.dataset.index = index;
      input.className = 'response-text';
      div.appendChild(input);
      // Show link info if exists
      const linkInfo = document.createElement('span');
      linkInfo.className = 'link-info';
      linkInfo.textContent = resp.nextNodeId ? `(→ ${resp.nextNodeId})` : '';
      div.appendChild(linkInfo);
      // Create branch button
      const branchBtn = document.createElement('button');
      branchBtn.textContent = 'Create Branch';
      branchBtn.dataset.index = index;
      branchBtn.className = 'create-branch';
      div.appendChild(branchBtn);
      // Link button
      const linkBtn = document.createElement('button');
      linkBtn.textContent = 'Link…';
      linkBtn.dataset.index = index;
      linkBtn.className = 'link-existing';
      div.appendChild(linkBtn);
      // Delete button
      const delBtn = document.createElement('button');
      delBtn.textContent = 'Delete';
      delBtn.dataset.index = index;
      delBtn.className = 'delete-response';
      div.appendChild(delBtn);

      // Add a Play button if this response leads to an existing node
      if (resp.nextNodeId) {
        const playBtn = document.createElement('button');
        playBtn.textContent = 'Play';
        playBtn.dataset.index = index;
        playBtn.className = 'play-response';
        div.appendChild(playBtn);
      }
      container.appendChild(div);
    });
  }

  // Render the conversation history as a clickable trail
  function renderHistory() {
    const list = document.getElementById('historyList');
    list.innerHTML = '';
    history.forEach((nid, idx) => {
      const n = nodes[nid];
      const span = document.createElement('span');
      const preview = getPreview(n.text);
      span.textContent = `${nid}: ${preview}`;
      span.style.cursor = 'pointer';
      span.dataset.index = idx;
      // Highlight the current node
      if (idx === history.length - 1) {
        span.style.fontWeight = 'bold';
        span.style.color = '#000';
      } else {
        span.style.fontWeight = 'normal';
        span.style.color = '#555';
      }
      // Add arrow separator except before first
      if (idx > 0) {
        const arrow = document.createElement('span');
        arrow.textContent = ' → ';
        arrow.style.color = '#888';
        list.appendChild(arrow);
      }
      list.appendChild(span);
    });
  }

  // Render the vertical conversation log between NPC and Player
  function renderConversationLog() {
    const logDiv = document.getElementById('conversationLog');
    logDiv.innerHTML = '';
    conversationLog.forEach(entry => {
      const p = document.createElement('p');
      let displayedSpeaker;
      let text;
      if (entry.type === 'npc') {
        // NPC entry: use current NPC name and current node text
        displayedSpeaker = npcName || 'NPC';
        const node = nodes[entry.nodeId];
        text = (node && node.text ? node.text : '[no text]');
        // Create clickable span for NPC text
        const strong = document.createElement('strong');
        strong.textContent = displayedSpeaker + ': ';
        p.appendChild(strong);
        const span = document.createElement('span');
        span.textContent = text;
        span.style.cursor = 'pointer';
        span.style.textDecoration = 'underline';
        span.style.color = '#0066cc';
        span.dataset.nodeId = entry.nodeId;
        p.appendChild(span);
      } else if (entry.type === 'player') {
        displayedSpeaker = 'Player';
        text = entry.text;
        const strong = document.createElement('strong');
        strong.textContent = displayedSpeaker + ': ';
        p.appendChild(strong);
        const span = document.createElement('span');
        span.textContent = text;
        p.appendChild(span);
      }
      logDiv.appendChild(p);
    });
  }

  // Navigate to a node, updating history and UI
  function navigateToNode(id, fromResponse) {
    // If coming from a player response, append the player and NPC lines to the conversation log
    if (fromResponse !== undefined) {
      conversationLog.push({ type: 'player', text: fromResponse });
      conversationLog.push({ type: 'npc', nodeId: id });
      renderConversationLog();
    } else {
      // If no conversation log yet, start with the NPC line for this node
      if (conversationLog.length === 0) {
        conversationLog.push({ type: 'npc', nodeId: id });
        renderConversationLog();
      }
    }
    // Update path history if this node isn't already the latest
    if (history.length === 0 || history[history.length - 1] !== id) {
      history.push(id);
    }
    renderNode(id);
    updateNodeSelect();
    renderHistory();
  }

  // Add a new response to the current node
  function addResponse() {
    if (!currentNodeId) return;
    nodes[currentNodeId].responses.push({ text: '', nextNodeId: null });
    renderNode(currentNodeId);
  }

  // Update the node selector dropdown
  function updateNodeSelect() {
    const select = document.getElementById('nodeSelect');
    // Clear existing options
    while (select.firstChild) select.removeChild(select.firstChild);
    Object.values(nodes)
      .sort((a,b) => a.id - b.id)
      .forEach(n => {
        const opt = document.createElement('option');
        opt.value = n.id;
        const preview = getPreview(n.text);
        opt.textContent = `${n.id}: ${preview}`;
        opt.title = n.text || '';
        select.appendChild(opt);
      });
    if (currentNodeId && nodes[currentNodeId]) {
      select.value = currentNodeId;
    }
  }

  // Download helper: triggers a file download for exported content
  function downloadFile(content, filename, mime) {
    const blob = new Blob([content], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Sanitize strings for use as filenames. Replace spaces and unsafe characters.
  function sanitizeFileName(name) {
    // Remove leading/trailing whitespace and replace invalid characters with underscores
    return (name || 'dialogue')
      .trim()
      .replace(/[^A-Za-z0-9-_ ]+/g, '')
      .replace(/\s+/g, '_') || 'dialogue';
  }

  // Export nodes as JSON
  function exportJSON() {
    const data = { npcName: npcName, start: currentNodeId, nodes: nodes };
    const json = JSON.stringify(data, null, 2);
    downloadFile(json, 'dialogue.json', 'application/json');
  }

  // Export nodes as a simple human-readable text representation. File name includes NPC name if provided.
  function exportText() {
    let out = [];
    Object.values(nodes)
      .sort((a,b) => a.id - b.id)
      .forEach(node => {
        out.push(`Node ${node.id}: ${node.text}`);
        node.responses.forEach((resp, idx) => {
          let line = `  ${idx + 1}. ${resp.text}`;
          if (resp.nextNodeId) line += ` -> ${resp.nextNodeId}`;
          out.push(line);
        });
        out.push('');
      });
    const base = sanitizeFileName(npcName);
    // Include '-dialogue' suffix so file clearly contains dialogue, but avoid duplication when base is 'dialogue'
    const filename = base === 'dialogue' ? 'dialogue.txt' : `${base}-dialogue.txt`;
    downloadFile(out.join('\n'), filename, 'text/plain');
  }

  // Handle file import
  function importFile(ev) {
    const file = ev.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = e => {
      const content = e.target.result;
      // Determine file type by extension
      const ext = (file.name.split('.').pop() || '').toLowerCase();
      if (ext === 'txt') {
        // Parse simple text format: Node lines followed by responses
        const parsedNodes = {};
        let currentId = null;
        const lines = content.split(/\r?\n/);
        lines.forEach(line => {
          const nodeMatch = line.match(/^\s*Node\s+(\d+):\s*(.*)$/);
          if (nodeMatch) {
            const nid = parseInt(nodeMatch[1], 10);
            const text = nodeMatch[2] || '';
            parsedNodes[nid] = { id: nid, text: text, responses: [] };
            currentId = nid;
          } else {
            const respMatch = line.match(/^\s*(\d+)\.\s*(.*?)\s*(?:->\s*(\d+))?\s*$/);
            if (respMatch && currentId !== null && parsedNodes[currentId]) {
              const rText = respMatch[2] || '';
              const destId = respMatch[3] ? parseInt(respMatch[3], 10) : null;
              parsedNodes[currentId].responses.push({ text: rText, nextNodeId: destId });
            }
          }
        });
        // If no nodes found, abort
        if (Object.keys(parsedNodes).length === 0) {
          alert('No dialogue nodes found in the text file.');
          return;
        }
        // Sort node ids and pick the smallest as starting node
        const sortedIds = Object.keys(parsedNodes).map(id => parseInt(id)).sort((a,b) => a - b);
        const startId = sortedIds[0];
        nodes = parsedNodes;
        currentNodeId = startId;
        nextNodeIdCounter = Math.max(...sortedIds) + 1;
        // Set npcName from file name (remove extension)
        const baseName = file.name.replace(/\.[^/.]+$/, '');
        npcName = baseName || '';
        // Update NPC name input
        const npcInputEl = document.getElementById('npcNameInput');
        if (npcInputEl) npcInputEl.value = npcName;
        // Reset history and conversation log
        history = [];
        conversationLog = [];
        updateNodeSelect();
        navigateToNode(currentNodeId);
      } else {
        // Attempt to parse as JSON
        try {
          const data = JSON.parse(content);
          if (data && data.nodes) {
            nodes = {};
            for (const [k, v] of Object.entries(data.nodes)) {
              nodes[k] = {
                id: v.id,
                text: v.text,
                responses: v.responses.map(r => ({ text: r.text, nextNodeId: r.nextNodeId }))
              };
            }
            // If start property missing, default to first key
            const idKeys = Object.keys(nodes).map(x => parseInt(x));
            currentNodeId = data.start || (idKeys.length > 0 ? Math.min(...idKeys) : null);
            nextNodeIdCounter = idKeys.length > 0 ? Math.max(...idKeys) + 1 : 1;
            npcName = data.npcName || '';
            const npcInputEl = document.getElementById('npcNameInput');
            if (npcInputEl) npcInputEl.value = npcName;
            // Reset history and conversation
            history = [];
            conversationLog = [];
            updateNodeSelect();
            if (currentNodeId !== null) navigateToNode(currentNodeId);
          }
        } catch (err) {
          alert('Unable to parse file. Please select a valid dialogue file.');
        }
      }
    };
    reader.readAsText(file);
  }

  // Event handler: handle buttons inside response rows
  function onResponsesClick(ev) {
    const target = ev.target;
    const index = parseInt(target.dataset.index, 10);
    if (isNaN(index)) return;
    if (target.classList.contains('play-response')) {
      // Play the selected response and move to its target node
      const resp = nodes[currentNodeId].responses[index];
      if (resp.nextNodeId) {
        navigateToNode(resp.nextNodeId, resp.text);
      }
    } else if (target.classList.contains('create-branch')) {
      // Create a new branch node and link this response to it; treat as playing through this branch
      const newId = createNode('');
      const respText = nodes[currentNodeId].responses[index].text;
      nodes[currentNodeId].responses[index].nextNodeId = newId;
      navigateToNode(newId, respText);
    } else if (target.classList.contains('link-existing')) {
      // Replace button with a dropdown to select existing node. Include a preview of the NPC text for each node.
      const dropdown = document.createElement('select');
      dropdown.dataset.index = index;
      dropdown.className = 'link-dropdown';
      // Add a placeholder option to prompt selection
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select node…';
      dropdown.appendChild(placeholder);
      // Populate the list sorted by id
      Object.values(nodes)
        .sort((a,b) => a.id - b.id)
        .forEach(n => {
          const option = document.createElement('option');
          option.value = n.id;
          const preview = getPreview(n.text);
          option.textContent = `${n.id}: ${preview}`;
          // Use the full NPC text in the title attribute for tooltips
          option.title = n.text || '';
          dropdown.appendChild(option);
        });
      target.replaceWith(dropdown);
      dropdown.addEventListener('change', function() {
        const dest = parseInt(this.value, 10);
        if (!isNaN(dest) && nodes[dest]) {
          nodes[currentNodeId].responses[index].nextNodeId = dest;
          // Re-render the node to refresh the UI
          renderNode(currentNodeId);
        }
      });
    } else if (target.classList.contains('delete-response')) {
      nodes[currentNodeId].responses.splice(index, 1);
      renderNode(currentNodeId);
    }
  }

  // Event handler: handle editing of response text
  function onResponsesInput(ev) {
    const target = ev.target;
    const index = parseInt(target.dataset.index, 10);
    // Only update the response text if the input field is the response text input
    // Skip if the input event came from the link dropdown or other elements
    if (!isNaN(index) && nodes[currentNodeId] && target.tagName === 'INPUT' && target.classList.contains('response-text')) {
      nodes[currentNodeId].responses[index].text = target.value;
    }
  }

  // DOM ready
  document.addEventListener('DOMContentLoaded', function() {
    // Bind top-level buttons
    document.getElementById('newNodeButton').addEventListener('click', function() {
      const newId = createNode('');
      navigateToNode(newId);
    });
    document.getElementById('exportTextButton').addEventListener('click', exportText);
    document.getElementById('importFile').addEventListener('change', importFile);
    document.getElementById('nodeSelect').addEventListener('change', function() {
      const selected = parseInt(this.value, 10);
      if (nodes[selected]) {
        // Reset conversation log when jumping via the dropdown
        conversationLog = [];
        navigateToNode(selected);
      }
    });
    document.getElementById('npcInput').addEventListener('input', function() {
      if (currentNodeId && nodes[currentNodeId]) {
        nodes[currentNodeId].text = this.value;
      }
    });
    document.getElementById('addResponseButton').addEventListener('click', addResponse);
    const respContainer = document.getElementById('responsesContainer');
    respContainer.addEventListener('click', onResponsesClick);
    respContainer.addEventListener('input', onResponsesInput);
    // Bind back button
    document.getElementById('backButton').addEventListener('click', function() {
      if (history.length > 1) {
        history.pop();
        const prevId = history[history.length - 1];
        // Reset conversation log when going back via the history
        conversationLog = [];
        navigateToNode(prevId);
      }
    });
    // Bind refresh names button
    document.getElementById('refreshNamesButton').addEventListener('click', function() {
      updateNodeSelect();
      renderHistory();
      renderConversationLog();
    });
    // Bind NPC name input
    const npcInputNameEl = document.getElementById('npcNameInput');
    npcInputNameEl.addEventListener('input', function() {
      npcName = this.value.trim();
      // Update conversation log to reflect new NPC name
      renderConversationLog();
    });
    // Bind history click handler
    document.getElementById('historyList').addEventListener('click', function(e) {
      const idx = parseInt(e.target.dataset.index, 10);
      if (!isNaN(idx) && idx < history.length) {
        // Only act if not already on the selected node
        if (idx !== history.length - 1) {
          history = history.slice(0, idx + 1);
          const id = history[history.length - 1];
          // Reset conversation log when jumping via the history trail
          conversationLog = [];
          navigateToNode(id);
        }
      }
    });
    // Initialize with one blank node
    const id = createNode('');
    // Clear conversation log and start at initial node
    conversationLog = [];
    navigateToNode(id);

    // Bind click on conversation log to navigate to NPC entries
    document.getElementById('conversationLog').addEventListener('click', function(e) {
      const nodeIdStr = e.target.dataset && e.target.dataset.nodeId;
      if (nodeIdStr) {
        const nodeId = parseInt(nodeIdStr, 10);
        if (!isNaN(nodeId) && nodes[nodeId]) {
          conversationLog = [];
          navigateToNode(nodeId);
        }
      }
    });
  });
})();
</script>
</body>
</html>
